Отчет 22.10
Задание 1
Admin panel
Разве тут нужно расписываться?
IP: 62.173.140.174:16077
Флаг формата: CODEBY{...}

Переходя по IP данном в задании мы попадаем на страницу с авторизацией.
Первым делом мы пытаемся зайти, используя случайные логин и пароль, на что получаем сообщение Invalid credentials
 
Заходим в Burp Suite, для того чтобы перехватывать трафик.
На сайте есть кнопка зарегистрироваться. Регистрируюсь как test test/
Попадаем на страницу с квалификацией пользователя и фейк ссылкой на флаг. 
 
Переходим в Burp. В истории запросов я вижу GET и POST запросы
В запросе /admin видим токен eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QiLCJyb2xlIjoidXNlciIsImV4cCI6MTc2MTMyNDY4OX0.Mph5eM4pqVpiGB-1dFtXC2T4GPh3tqEwj_q4lYpLTH8
 
Находим в BApp Store расширение JSON Web Tokens и устанавливаем его
 
Перекидываем запрос в репитер и во вкладке инструментов выбираем расширение.
 
Переименовываем юзер и роль на желаемые. Допустим admin. Производим атаку на JWT токен.
Меняем «HS256» на «none» и удаляем подпись(символы после точки). Отсылаем наш запрос и видим Флаг CODEBY{I&#39;M_G0NN4_H4V3_70_F1R3_7H3_C0D3R}
 
Декодируем это через HTML и получаем CODEBY{I'M_G0NN4_H4V3_70_F1R3_7H3_C0D3R}

Задание 2
Описание с платформы:
Здесь Вы можете скачать любой понравившийся Вам PDF-файл. В дальнейшем библиотеку ждет пополнение. IP: 62.173.140.174:16081

Переходя по IP мы видим страницу с двумя PDF файлами 
При переходе на файлы в URL можно увидеть как добавляется часть, которая скорее всего закодирована. Попробуем расшифровать через Burp decoder
Расшифровав этот код, мы получаем название файла. Теперь мы понимаем, как работает логика.
Меняем хвост с названием файла на index.php зашифрованным в hex. Получаем строку http://62.173.140.174:16081/index.php?file=696E6465782E706870
Пробиваем её с помощью curl. И получаем код страницы .php.
 
Получаем 2 интересные строки
/ $php_files = array_slice(['test.php', 'index.php'], 0, 2);
// $txt_files = array_slice(['test.txt', 'flag_for_hackerlab_ctfplayers.txt'], 0, 2); // Moved to upper directory
Во второй строке мы видим название файла 'flag_for_hackerlab_ctfplayers.txt'.
В комментарии сказано что надо двигаться на директорию выше, т.е. ../
Берем название нашего файла, приписываем в начало ../ и зашифровываем все в hex.  
Пробиваем через curl с заменой хвоста на наш файл и получаем строку CODEBY{h3x3d_lf1_beaut1fulll}
 

Задача 3
Странный файл 
В задании мы получаем файл. Он не открывается. Значит работаем через hex сигнатуру. 
В данной работе используем https://hex-works.com/
https://en.wikipedia.org/wiki/List_of_file_signatures?ysclid=mg1v71wu4j44009701
https://pychaos.io/
Открываем файл в Hex editor.
Первые биты кода которые мы видим это 52 61 72 21 1А 07 00. В википедии пишут что это . rar архив 
Открываем Архив и видим файл dhsa
Производим те же действия по отношению к этому файлу
 
Первая строка 50 4B 03 04. На вики это куча разных форматов. Перебираем. Первое это .zip. Получилось. Это zip архив
В нем файл task1. Продолжаем открывать нашу матрешку. Также забиваем это в hex.  
Получаем строку 52 61 72 21 1А 07 00. Получаем что это .rar архив
 
Мы получили иной файл. Открываем его в https://pychaos.io/
Получаем код
 
Вбиваем его в любой компилятор кода. Я использую VS code. 
import base64
def encrypt(flag):
  flag = flag.encode()
  mid = len(flag)//2
  part1 = flag[:mid]
  part2 = flag[mid:]
  key = [19,55,66]
  enc1 = bytes([part1[i]^key[i%len(key)] for i in range(len(part1))])
  enc2 = bytes([part2[i]^key[(i+1)%len(key)] for i in range(len(part2))])
  combined = enc1+enc2
  return base64.b64encode(combined).decode()

def decrypt(encrypted_flag):
  combined = base64.b64decode(encrypted_flag)
  mid = len(combined)//2
  part1_enc = combined[:mid]
  part2_enc = combined[mid:]
  key = [19,55,66]
  part1 = bytes([part1_enc[i]^key[i%len(key)] for i in range(len(part1_enc))])
  part2 = bytes([part2_enc[i]^key[(i+1)%len(key)] for i in range(len(part2_enc))])
  flag_bytes = part1+part2
  return flag_bytes.decode()

encrypted = 'flgxY1guakw6I0UdJ1kmTFV2YAR0J2goRnERSgAkd0o='
if __name__ == '__main__':
  print (decrypt(encrypted))
"""  while True:
    flag = input('Enter flag: ')
    if flag == 'help':
      print('...no?')
      break
    else:
      if flag == 'hi' or flag == 'hello':
        print('Hello!')
        break
      else:
        if encrypt(flag) == encrypted:
          print('Congrats!')
          break
        else:
          print('Try again!')"""
 Здесь мы комментируем последний блок кода, который действует на ввод, а также поправляем код сверху, иначе выдает ошибку. В ответ получаем флаг mospoly{x0r_4nd_b4s364_jUFSY7fd}

Это очень многогранное и интересное задание. Вышло очень занимательным, но это просто полный 0J/QmNCX0JTQldCm. 

Задание 4
Тебе дан исполняемый файл (ELF). Твоя задача — с помощью инструментов Kali Linux (objdump, nm, xxd и т.д.) найти, где хранится флаг и как он проверяется программой. Нужно исследовать бинарник, найти XOR-ключ и расшифровать флаг.
Флаг в таком формате - FLAG{...}
Подсказка в последнем шаге где мы создаем файл был показан код в ходе проверки он выводил не верные значения поэтому рекомендую использовать это
import re
d=open('enc.bin','rb').read()
for k in range(1,256):
dec = bytes([b ^ k for b in d])
  
if b'FLAG{' in dec:
  
    try:
      
        s = dec.decode('utf-8', 
          
      errors='ignore')
    except:
      
        s = dec.decode('latin1', errors='ignore')
          
    m = re.search(r'FLAG\{.*?\}', s)
      
    print(f"FOUND KEY=0x{k:02X}
      
      FLAG={m.group(0) if m else s}")
    break
 
Начинаем работу.
Открываем Файл с помощью file 1 
Вбиваем еще парочку команд, такие как ls –l 1 и strings 1 | head –n 40

Видим флаг, но он зашифрован. Работаем далее
Вводим readelf –s 1 
Ищем .rodata. Не находим. Проверяем бинарник с помощью 
objdump -d 1 | grep -n "0x" | head -n 50
 
Здесь ничего важного не видим.
Вводим nm -C 1 | grep key –n
  
Получаем 21:0000000000001220 T get_key
Вводим следующую команду
objdump -d -M intel --start-address=0x1220 --stop-address=0x1250 1
 
Получаем ключ на 61
Вводим  objdump -s -j .rodata 1 | grep -oP '([0-9a-f]{2}(?: [0-9a-f]{2}){0,15})' | tr -d ' \n' > enc.hex

 

Выполняем преобразования сначала в hex потом в bin.
Была дана подсказка в виде python кода. 
Первоначальный код был дан неправильно
import re
d = open('enc.bin', 'rb').read()
for k in range(1, 256):
    dec = bytes([b ^ k for b in d])
    if b'FLAG{' in dec:
        try:
            s = dec.decode('utf-8', errors='ignore')
        except:
            s = dec.decode('latin1', errors='ignore'
        m = re.search(r'FLAG\{.*?\}', s)
        print(f"FOUND KEY=0x{k:02X}")
        print(f"FLAG={m.group(0) if m else s}")
        break
используем код и получаем Флаг