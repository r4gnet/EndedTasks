### XORSA(CRYPTO)

## 1. Постановка задачи

Даны параметры RSA-шифрования и XOR-шифрования флага:
- Модуль RSA: `n = 66198971698667626765944815224782654873840391544915906938883244716164862363934160507586506697076449072844851822514766616158373497290084059084572179968408998330656546636700236692662304141585660002990151611178245198542785211634777181599357600946603235304633565422700835598174445336832200832474361827564409640653`
- Шифротекст RSA: `c = 7909628388722349922026000796369904154754870043467924538646750692558839699959188311950225249912181943340447814258642765415584559383400716077797261462253392051177633213671341162600084678524736244177858359444505705375151780091622007189624527808666142433823575255166638317581931865191245934324356962633320716177`
- Публичная экспонента: `e = 65537`
- Флаг начинается с префикса `f13{`

Кроме того, известно, что:
1. Флаг сначала был зашифрован XOR с keystream, который генерируется по алгоритму:
   - `ks[0] = random(32, 255)`
   - `ks[i] = (ks[i-1] * 9) % 256` для i = 1..31
   - Период keystream: 32 байта
2. Результат XOR-шифрования был преобразован в целое число `m`
3. Число `m` было зашифровано с помощью RSA: `c = m^e mod n`
4. Простые числа `p` и `q` для RSA генерировались так:
   - `p = randprime(2^511, 2^512)`
   - `q = nextprime(p + 2025)`

## 2. Этапы решения

### 2.1. Факторизация модуля RSA

Поскольку `p` и `q` близки друг к другу (разность около 2025), можно применить метод Ферма для факторизации:
- Находим `a = ceil(sqrt(n)) + 1`
- Вычисляем `b^2 = a^2 - n`
- Проверяем, является ли `b^2` полным квадратом
- Если да, то `p = a - b`, `q = a + b`

Реализация:
```python
sqrt_n = math.isqrt(n)
a = sqrt_n + 1
while True:
    b2 = a*a - n
    if b2 < 0:
        a += 1
        continue
    b = math.isqrt(b2)
    if b*b == b2:
        p = a - b
        q = a + b
        break
    a += 1
```

### 2.2. Вычисление секретной экспоненты

После нахождения `p` и `q`:
1. Вычисляем функцию Эйлера: `φ(n) = (p-1)*(q-1)`
2. Находим секретную экспоненту `d` как модульное обратное к `e` по модулю `φ(n)`:
   - `d = e^(-1) mod φ(n)`

### 2.3. Расшифровка RSA

Восстанавливаем число `m`:
- `m = c^d mod n`

### 2.4. Преобразование в байты

Переводим число `m` в байтовую строку:
- `enc_bytes = m.to_bytes((m.bit_length() + 7) // 8, 'big')`

### 2.5. Восстановление keystream

Используем известный префикс флага `f13{`:
1. Для первых 4 байт: `enc_bytes[i] ^ ks[i] = known_prefix[i]`
2. Отсюда: `ks[i] = enc_bytes[i] ^ known_prefix[i]`
3. Проверяем согласованность с алгоритмом генерации:
   - `ks[1] = (ks[0] * 9) % 256`
   - `ks[2] = (ks[1] * 9) % 256`
   - `ks[3] = (ks[2] * 9) % 256`

### 2.6. Генерация полного keystream

Восстанавливаем начальное значение `ks[0]` и генерируем 32 байта:
```python
def generate_ks(ks0, length):
    ks = [0]*length
    ks[0] = ks0
    for i in range(1, length):
        ks[i] = (ks[i-1] * 9) % 256
    return ks
```

### 2.7. Расшифровка флага

Применяем операцию XOR к зашифрованным байтам с циклическим использованием keystream:
```python
flag_bytes = bytearray()
for i in range(len(enc_bytes)):
    flag_byte = enc_bytes[i] ^ ks[i % 32]
    flag_bytes.append(flag_byte)
flag = flag_bytes.rstrip(b'\x00').decode('ascii')
```

## 3. Найденные значения

### 3.1. Простые числа
- `p = 81312698469296904893502266472377471560354436663247326328985277022386112476778091973793502258147625940235430548999511676658877541187387973843980682767912766171452221227883031`
- `q = 81312698469296904893502266472377471560354436663247326328985277022386112476778091973793502258147625940235430548999511676658877541187387973843980682767912766171452221227890056`

### 3.2. Проверка
- `n = p * q` соответствует заданному значению
- `q = nextprime(p + 2025)` выполняется

### 3.3. Секретная экспонента
- `d = 36369564871072748869184532451375572652948613380843717871282838372061283422974999199022778507953197970625047090827308975986848362634078856938056274420430818617938589982687248888083725754776692990539454608763146389697902907274665721833128856512286521705953502025608924158483269010089287605478871792061930386161`

### 3.4. Число m
- `m = 2050404262073416465925136377506063454103343246192417267913075782904727689906116499859153664015094336`

### 3.5. Keystream
- Начальное значение: `ks[0] = 175`
- Первые 8 байт keystream: `[175, 119, 159, 223, 255, 239, 15, 135]`

### 3.6. Флаг
- **f13{f0und_XORed_byte5_and_fl4g_tabyldy!}**

## 4. Ключевые моменты решения

1. **Уязвимость генерации ключей RSA**: Близость простых чисел `p` и `q` позволяет применить метод Ферма для быстрой факторизации.
2. **Знание структуры флага**: Префикс `f13{` позволяет восстановить keystream без полного перебора.
3. **Детерминированность keystream**: Алгоритм генерации keystream полностью детерминирован и зависит только от начального значения.
4. **Согласованность данных**: Проверка соответствия восстановленного keystream алгоритму генерации исключает ложные срабатывания.


### Syrenka (OSINT)
Дана фотография
![Image alt](https://github.com/r4gnet//EndedTasks/raw/photo/chall.png)

На ней мы видим здание Samsung в отдалении. Также мы можем увидеть флаг Польши. Вводим в поиск в интернете Samsung Польша.
Выдает фотографии похожих мест и мы видим что назваие здания не то, однако, в режиме панорамы мы можем спококйно найти нужное место с нужным ракурсом неподалеку от Warsaw Marriot Hotel. Задание выполнено.